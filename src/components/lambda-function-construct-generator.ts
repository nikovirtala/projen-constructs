import * as path from "node:path";
import type { BuildOptions } from "@mrgrain/cdk-esbuild";
import { Component, SourceCode } from "projen";
import type { NodeProject } from "projen/lib/javascript";

export interface LambdaFunctionConstructGeneratorOptions {
    readonly sourceDir?: string;
    readonly outputDir?: string;
    readonly filePattern?: string;
    readonly esbuildOptions?: BuildOptions;
    readonly addDependencies?: boolean;
    readonly baseConstructImport?: string;
    readonly baseConstructClass?: string;
    readonly baseConstructPackage?: string;
}

export class LambdaFunctionConstructGenerator extends Component {
    public readonly sourceDir: string;
    public readonly outputDir: string;
    public readonly filePattern: string;
    public readonly esbuildOptions: BuildOptions;
    public readonly baseConstructImport?: string;
    public readonly baseConstructClass?: string;
    public readonly baseConstructPackage?: string;
    private readonly nodeProject: NodeProject;
    private readonly bundlerScriptPath: string;

    constructor(project: NodeProject, options?: LambdaFunctionConstructGeneratorOptions) {
        super(project);
        this.nodeProject = project;
        this.sourceDir = options?.sourceDir ?? "src/handlers";
        this.outputDir = options?.outputDir ?? "src/constructs/lambda";
        this.filePattern = options?.filePattern ?? "*.lambda.ts";
        this.esbuildOptions = options?.esbuildOptions ?? {};
        this.baseConstructImport = options?.baseConstructImport;
        this.baseConstructClass = options?.baseConstructClass;
        this.baseConstructPackage = options?.baseConstructPackage;

        const uniqueId = this.createUniqueId(this.sourceDir, this.filePattern);
        this.bundlerScriptPath = path.join(".projen", `generate-and-bundle-${uniqueId}.ts`);

        if (options?.addDependencies ?? true) {
            this.addDependencies(options?.baseConstructPackage);
        }

        this.createBundleTask();
        this.addBundleTaskToWorkflow();
    }

    private addDependencies(additionalPackage?: string) {
        this.nodeProject.addDeps("aws-cdk-lib", "constructs");

        if (additionalPackage && additionalPackage !== "aws-cdk-lib" && additionalPackage !== "constructs") {
            this.nodeProject.addDeps(additionalPackage);
        }
    }

    private createUniqueId(sourceDir: string, filePattern: string): string {
        const dirPart = sourceDir.replace(/\//g, "-").replace(/[^\w-]/g, "");
        const patternPart = filePattern
            .replace(/\*/g, "")
            .replace(/\./g, "-")
            .replace(/[^\w-]/g, "");
        return `${dirPart}-${patternPart}`.replace(/--+/g, "-").replace(/^-|-$/g, "");
    }

    private createBundleTask() {
        const uniqueId = this.createUniqueId(this.sourceDir, this.filePattern);
        const taskName = `generate-and-bundle-${uniqueId}`;

        let baseConstructArgs = "";
        if (this.baseConstructImport) {
            baseConstructArgs += ` --base-construct-import '${this.baseConstructImport}'`;
        }
        if (this.baseConstructClass) {
            baseConstructArgs += ` --base-construct-class '${this.baseConstructClass}'`;
        }

        const bundleTask = this.nodeProject.addTask(taskName, {
            description: `Generate Lambda Function Constructs from ${this.sourceDir}/${this.filePattern} and bundle their handlers`,
            exec: `tsx --tsconfig tsconfig.dev.json ${this.bundlerScriptPath} --source-dir ${this.sourceDir} --output-dir ${this.outputDir} --file-pattern "${this.filePattern}" --esbuild-options '${JSON.stringify(this.esbuildOptions)}'${baseConstructArgs}`,
        });

        this.createBundlerScript();

        return bundleTask;
    }

    private createBundlerScript() {
        const bundlerScript = `// ~~ Generated by projen. To modify, edit .projenrc.ts and run "npx projen".

import * as path from 'path';
import * as fs from 'fs';
import * as esbuild from 'esbuild';
import * as glob from 'glob';
import { pascalCase } from 'change-case';
import yargs from 'yargs/yargs';
import { hideBin } from 'yargs/helpers';

async function main() {
  const argv = await yargs(hideBin(process.argv))
    .option('source-dir', { type: 'string', default: 'src/handlers', description: 'Source directory where Lambda Function handlers are located' })
    .option('output-dir', { type: 'string', default: 'src/constructs/lambda', description: 'Output directory where Lambda Function constructs will be generated' })
    .option('file-pattern', { type: 'string', default: '*.lambda.ts', description: 'File pattern to identify Lambda Function handlers' })
    .option('esbuild-options', { type: 'string', default: '{}', description: 'esbuild options as JSON string' })
    .option('base-construct-import', { type: 'string', description: 'Import statement for the base construct' })
    .option('base-construct-class', { type: 'string', description: 'Name of the construct class to extend' })
    .help()
    .parse();

  const sourceDir = argv['source-dir'];
  const outputDir = argv['output-dir'];
  const filePattern = argv['file-pattern'];
  const esbuildOptions = JSON.parse(argv['esbuild-options'] as string);
  const baseConstructImport = argv['base-construct-import'] as string | undefined;
  const baseConstructClass = argv['base-construct-class'] as string | undefined;

  fs.mkdirSync(path.join(process.cwd(), outputDir), { recursive: true });

  const assetsDir = path.join(process.cwd(), 'assets', 'handlers');
  fs.mkdirSync(assetsDir, { recursive: true });

  const handlerFiles = glob.sync(path.join(process.cwd(), sourceDir, filePattern));

  console.log(\`Found \${handlerFiles.length} Lambda Function handler files\`);

  for (const handlerFile of handlerFiles) {
    const relativePath = path.relative(path.join(process.cwd(), sourceDir), handlerFile);
    const fileName = path.basename(relativePath, path.extname(relativePath));
    const functionName = fileName.replace('.lambda', '');

    console.log(\`Processing Lambda Function handler: \${functionName}\`);

    const functionDir = path.join(assetsDir, functionName);
    fs.mkdirSync(functionDir, { recursive: true });

    const outfile = path.join(functionDir, 'index.js');

    try {
      await esbuild.build({
        entryPoints: [handlerFile],
        bundle: true,
        minify: true,
        platform: 'node',
        target: 'node18',
        outfile,
        ...esbuildOptions,
      });

      console.log(\`Successfully bundled \${functionName} to \${outfile}\`);

      const constructFilePath = path.join(process.cwd(), outputDir, \`\${functionName}.ts\`);
      const constructCode = generateConstructCode(functionName, relativePath, baseConstructImport, baseConstructClass);

      fs.writeFileSync(constructFilePath, constructCode);
      console.log(\`Generated construct at \${constructFilePath}\`);
    } catch (error) {
      console.error(\`Error processing \${functionName}:\`, error);
    }
  }
}

function generateConstructCode(functionName: string, handlerPath: string, baseConstructImport?: string, baseConstructClass?: string) {
  const constructName = \`\${pascalCase(functionName)}Function\`;

  const importStatement = baseConstructImport ?? "";
  const baseClassName = baseConstructClass ?? "aws_lambda.Function";

  const useAwsLambdaRuntime = !baseConstructClass || baseClassName.includes("Function");

  return \`// ~~ Generated by projen. To modify, edit .projenrc.ts and run "npx projen".

import * as path from 'path';
import { fileURLToPath } from 'url';
\${importStatement}
import { aws_lambda } from 'aws-cdk-lib';
import { Construct } from 'constructs';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export interface \${constructName}Props extends Omit<\${baseClassName === "aws_lambda.Function" ? "aws_lambda.FunctionProps" : \`\${baseClassName}Props\`}, 'code'\${useAwsLambdaRuntime ? " | 'runtime'" : ""} | 'handler'> {
  \${useAwsLambdaRuntime ? \`/**
   * Override the default runtime
   * @default nodejs22.x
   */
  readonly runtime?: aws_lambda.Runtime;\` : ""}
}

export class \${constructName} extends \${baseClassName} {
  constructor(scope: Construct, id: string, props: \${constructName}Props = {}) {
    super(scope, id, {
      ...props,
      \${useAwsLambdaRuntime ? "runtime: props.runtime ?? aws_lambda.Runtime.NODEJS_22_X," : ""}
      handler: 'index.handler',
      code: aws_lambda.Code.fromAsset(path.join(__dirname, '../../../assets/handlers/\${functionName}')),
    });
  }
}
\`;
}

main().catch(error => {
  console.error('Error:', error);
  process.exit(1);
});
`;

        const src = new SourceCode(this.project, this.bundlerScriptPath);
        const lines = bundlerScript.split("\n");
        for (const line of lines) {
            src.line(line);
        }

        this.nodeProject.addDevDeps("esbuild", "glob", "yargs", "@types/glob", "@types/yargs", "tsx", "change-case");
    }

    private addBundleTaskToWorkflow() {
        const compileTask = this.nodeProject.tasks.tryFind("compile");

        if (compileTask) {
            const uniqueId = this.createUniqueId(this.sourceDir, this.filePattern);
            const taskName = `generate-and-bundle-${uniqueId}`;
            const bundleTask = this.nodeProject.tasks.tryFind(taskName);
            if (bundleTask) {
                compileTask.prependSpawn(bundleTask);
            }
        }
    }
}
